{"version":3,"file":"react-style-tag.min.js","sources":["../src/blob.ts","../src/options.ts","../src/styles.ts","../src/Style.tsx","../src/hash.ts"],"sourcesContent":["const noop = function noopCreateObjectUrl(): undefined {\n  return;\n} as unknown as typeof URL.createObjectURL;\n\n/**\n * Create a cached version of the getLinkHref.\n */\nexport function createGetCachedLinkHref(): (\n  style: string\n) => string | undefined {\n  let href: string | undefined;\n  let createObjectURL: ReturnType<typeof getCreateObjectURL> =\n    getCreateObjectURL();\n  let currentStyle: string | null = null;\n\n  return function getCachedLinkedHref(style: string): string | undefined {\n    if (style === currentStyle) {\n      return href;\n    }\n\n    if (createObjectURL === noop) {\n      createObjectURL = getCreateObjectURL();\n    }\n\n    if ((currentStyle = style)) {\n      return (href = createObjectURL(new Blob([style], { type: 'text/css' })));\n    }\n\n    return (href = undefined);\n  };\n}\n/**\n * Create the url string based on the available URL. If window is unavailable (such as in SSR),\n * then bail out.\n */\nexport function getCreateObjectURL(): typeof URL.createObjectURL {\n  if (typeof window === 'undefined') {\n    return noop;\n  }\n\n  const URL = window.URL || window.webkitURL;\n\n  return URL.createObjectURL || noop;\n}\n","import { Options } from '../index.d';\n\nconst IS_PRODUCTION =\n  typeof process !== 'undefined' && process.env?.NODE_ENV === 'production';\n\n/**\n * The global options to apply as fallback to local props.\n */\nexport const DEFAULT_OPTIONS: Options = {\n  hasSourceMap: !IS_PRODUCTION,\n  isMinified: IS_PRODUCTION,\n  isPrefixed: true,\n};\n\nconst globalOptions: Options = Object.assign({}, DEFAULT_OPTIONS);\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * Get the option either from props if it exists, or globally.\n */\nexport function getCoalescedOption(\n  props: Record<string, any>,\n  option: keyof Options\n): boolean {\n  const value = props[option];\n\n  return value != null ? !!value : globalOptions[option];\n}\n\nexport function getGlobalOptions(): Options {\n  return globalOptions;\n}\n\nexport function normalizeOptions(options: Partial<Options>): Options {\n  const normalized: Options = Object.assign({}, globalOptions);\n  let option: keyof Options;\n\n  for (option in options) {\n    if (hasOwnProperty.call(normalized, option) && options[option] != null) {\n      normalized[option] = !!options[option];\n    }\n  }\n\n  return normalized;\n}\n\n/**\n * Set the options passed to be global.\n */\nexport function setGlobalOptions(options: Partial<Options>): void {\n  let option: keyof Options;\n\n  for (option in options) {\n    if (hasOwnProperty.call(globalOptions, option)) {\n      globalOptions[option] = !!options[option];\n    }\n  }\n}\n","import { compile, serialize, stringify, middleware, prefixer } from 'stylis';\n\nimport type { Options } from '../index.d';\n\ninterface BeautifyOptions {\n  autosemicolon?: boolean;\n  indent?: string;\n  openbrace?: boolean | string;\n}\n\ninterface BeautifyState {\n  Start: number;\n  AtRule: number;\n  Block: number;\n  Selector: number;\n  Ruleset: number;\n  Property: number;\n  Separator: number;\n  Expression: number;\n  URL: number;\n}\n\n// FIXME: handle Unicode characters\nfunction isName(character: string): boolean {\n  return (\n    (character >= 'a' && character <= 'z') ||\n    (character >= 'A' && character <= 'Z') ||\n    (character >= '0' && character <= '9') ||\n    '-_*.:#[]'.indexOf(character) >= 0\n  );\n}\n\nfunction isQuote(char: string | null | undefined): boolean {\n  return char === \"'\" || char === '\"';\n}\n\nfunction isWhitespace(char: string): boolean {\n  return (\n    char === ' ' ||\n    char === '\\n' ||\n    char === '\\t' ||\n    char === '\\r' ||\n    char === '\\f'\n  );\n}\n\nexport function beautify(style: string, options: BeautifyOptions = {}): string {\n  // We want to deal with LF (\\n) only\n  style = style.replace(/\\r\\n/g, '\\n');\n\n  const {\n    autosemicolon = false,\n    indent = '  ',\n    openbrace: openbracesuffix = true,\n  } = options;\n\n  let index = 0;\n  const length = style.length;\n  const blocks: string[] = [];\n  let formatted = '';\n  let character: string;\n  let character2: string;\n  let string: string;\n  const State: BeautifyState = {\n    Start: 0,\n    AtRule: 1,\n    Block: 2,\n    Selector: 3,\n    Ruleset: 4,\n    Property: 5,\n    Separator: 6,\n    Expression: 7,\n    URL: 8,\n  };\n  let state = State.Start;\n  let depth = 0;\n  let quote;\n  let comment = false;\n\n  function appendIndent() {\n    for (let index = depth; index > 0; --index) {\n      formatted += indent;\n    }\n  }\n\n  function openBlock() {\n    formatted = formatted.trimEnd();\n\n    if (openbracesuffix) {\n      formatted += ' {';\n    } else {\n      formatted += '\\n';\n      appendIndent();\n      formatted += '{';\n    }\n\n    if (character2 !== '\\n') {\n      formatted += '\\n';\n    }\n\n    depth += 1;\n  }\n\n  function closeBlock() {\n    let last;\n\n    depth -= 1;\n    formatted = formatted.trimEnd();\n\n    if (formatted.length > 0 && autosemicolon) {\n      last = formatted.charAt(formatted.length - 1);\n\n      if (last !== ';' && last !== '{') {\n        formatted += ';';\n      }\n    }\n\n    formatted += '\\n';\n    appendIndent();\n    formatted += '}';\n    blocks.push(formatted);\n    formatted = '';\n  }\n\n  while (index < length) {\n    character = style.charAt(index);\n    character2 = style.charAt(index + 1);\n    ++index;\n\n    // Inside a string literal?\n    if (isQuote(quote)) {\n      formatted += character;\n\n      if (character === quote) {\n        quote = null;\n      }\n\n      if (character === '\\\\' && character2 === quote) {\n        // Don't treat escaped character as the closing quote\n        formatted += character2;\n        ++index;\n      }\n\n      continue;\n    }\n\n    // Starting a string literal?\n    if (isQuote(character)) {\n      formatted += character;\n      quote = character;\n\n      continue;\n    }\n\n    // Comment\n    if (comment) {\n      formatted += character;\n\n      if (character === '*' && character2 === '/') {\n        comment = false;\n        formatted += character2;\n        ++index;\n      }\n\n      continue;\n    }\n    if (character === '/' && character2 === '*') {\n      comment = true;\n      formatted += character;\n      formatted += character2;\n      ++index;\n\n      continue;\n    }\n\n    if (state === State.Start) {\n      if (\n        blocks.length === 0 &&\n        isWhitespace(character) &&\n        formatted.length === 0\n      ) {\n        continue;\n      }\n\n      // Copy white spaces and control characters\n      if (character <= ' ' || character.charCodeAt(0) >= 128) {\n        state = State.Start;\n        formatted += character;\n\n        continue;\n      }\n\n      // Selector or at-rule\n      if (isName(character) || character === '@') {\n        // Clear trailing whitespaces and linefeeds.\n        string = formatted.trimEnd();\n\n        if (string.length === 0) {\n          // If we have empty string after removing all the trailing\n          // spaces, that means we are right after a block.\n          // Ensure a blank line as the separator.\n          if (blocks.length > 0) {\n            formatted = '\\n\\n';\n          }\n        } else {\n          const lastChar = string.charAt(string.length - 1);\n\n          // After finishing a ruleset or directive statement,\n          // there should be one blank line.\n          if (lastChar === '}' || lastChar === ';') {\n            formatted = string + '\\n\\n';\n          } else {\n            // After block comment, keep all the linefeeds but\n            // start from the first column (remove whitespaces prefix).\n            // eslint-disable-next-line no-constant-condition\n            while (true) {\n              character2 = formatted.charAt(formatted.length - 1);\n\n              if (character2 !== ' ' && character2.charCodeAt(0) !== 9) {\n                break;\n              }\n\n              formatted = formatted.substr(0, formatted.length - 1);\n            }\n          }\n        }\n\n        formatted += character;\n        state = character === '@' ? State.AtRule : State.Selector;\n\n        continue;\n      }\n    }\n\n    if (state === State.AtRule) {\n      // ';' terminates a statement.\n      if (character === ';') {\n        formatted += character;\n        state = State.Start;\n\n        continue;\n      }\n\n      // '{' starts a block\n      if (character === '{') {\n        string = formatted.trimEnd();\n        openBlock();\n        state = string === '@font-face' ? State.Ruleset : State.Block;\n\n        continue;\n      }\n\n      formatted += character;\n\n      continue;\n    }\n\n    if (state === State.Block) {\n      // Selector\n      if (isName(character)) {\n        // Clear trailing whitespaces and linefeeds.\n        string = formatted.trimEnd();\n\n        if (string.length === 0) {\n          // If we have empty string after removing all the trailing\n          // spaces, that means we are right after a block.\n          // Ensure a blank line as the separator.\n          if (blocks.length > 0) {\n            formatted = '\\n\\n';\n          }\n        } else {\n          // Insert blank line if necessary.\n          if (string.charAt(string.length - 1) === '}') {\n            formatted = string + '\\n\\n';\n          } else {\n            // After block comment, keep all the linefeeds but\n            // start from the first column (remove whitespaces prefix).\n            // eslint-disable-next-line no-constant-condition\n            while (true) {\n              character2 = formatted.charAt(formatted.length - 1);\n\n              if (character2 !== ' ' && character2.charCodeAt(0) !== 9) {\n                break;\n              }\n\n              formatted = formatted.substr(0, formatted.length - 1);\n            }\n          }\n        }\n\n        appendIndent();\n        formatted += character;\n        state = State.Selector;\n\n        continue;\n      }\n\n      // '}' resets the state.\n      if (character === '}') {\n        closeBlock();\n        state = State.Start;\n\n        continue;\n      }\n\n      formatted += character;\n\n      continue;\n    }\n\n    if (state === State.Selector) {\n      // '{' starts the ruleset.\n      if (character === '{') {\n        openBlock();\n        state = State.Ruleset;\n\n        continue;\n      }\n\n      // '}' resets the state.\n      if (character === '}') {\n        closeBlock();\n        state = State.Start;\n\n        continue;\n      }\n\n      formatted += character;\n\n      continue;\n    }\n\n    if (state === State.Ruleset) {\n      // '}' finishes the ruleset.\n      if (character === '}') {\n        closeBlock();\n        state = State.Start;\n\n        if (depth > 0) {\n          state = State.Block;\n        }\n\n        continue;\n      }\n\n      // Make sure there is no blank line or trailing spaces inbetween\n      if (character === '\\n') {\n        formatted = formatted.trimEnd();\n        formatted += '\\n';\n\n        continue;\n      }\n\n      // property name\n      if (!isWhitespace(character)) {\n        formatted = formatted.trimEnd();\n        formatted += '\\n';\n        appendIndent();\n        formatted += character;\n        state = State.Property;\n\n        continue;\n      }\n\n      formatted += character;\n\n      continue;\n    }\n\n    if (state === State.Property) {\n      // ':' concludes the property.\n      if (character === ':') {\n        formatted = formatted.trimEnd();\n        formatted += ': ';\n        state = State.Expression;\n\n        if (isWhitespace(character2)) {\n          state = State.Separator;\n        }\n\n        continue;\n      }\n\n      // '}' finishes the ruleset.\n      if (character === '}') {\n        closeBlock();\n        state = State.Start;\n\n        if (depth > 0) {\n          state = State.Block;\n        }\n\n        continue;\n      }\n\n      formatted += character;\n\n      continue;\n    }\n\n    if (state === State.Separator) {\n      // Non-whitespace starts the expression.\n      if (!isWhitespace(character)) {\n        formatted += character;\n        state = State.Expression;\n\n        continue;\n      }\n\n      // Anticipate string literal.\n      if (isQuote(character2)) {\n        state = State.Expression;\n      }\n\n      continue;\n    }\n\n    if (state === State.Expression) {\n      // '}' finishes the ruleset.\n      if (character === '}') {\n        closeBlock();\n        state = State.Start;\n\n        if (depth > 0) {\n          state = State.Block;\n        }\n\n        continue;\n      }\n\n      // ';' completes the declaration.\n      if (character === ';') {\n        formatted = formatted.trimEnd();\n        formatted += ';\\n';\n        state = State.Ruleset;\n\n        continue;\n      }\n\n      formatted += character;\n\n      if (\n        character === '(' &&\n        formatted.charAt(formatted.length - 2) === 'l' &&\n        formatted.charAt(formatted.length - 3) === 'r' &&\n        formatted.charAt(formatted.length - 4) === 'u'\n      ) {\n        // URL starts with '(' and closes with ')'.\n        state = State.URL;\n\n        continue;\n      }\n\n      continue;\n    }\n\n    if (\n      state === State.URL &&\n      // ')' finishes the URL (only if it is not escaped).\n      character === ')' &&\n      formatted.charAt(\n        // @ts-expect-error - testing multiline\n        formatted.length - 1 !== '\\\\' ? 1 : 0\n      )\n    ) {\n      formatted += character;\n      state = State.Expression;\n\n      continue;\n    }\n\n    // The default action is to copy the character (to prevent\n    // infinite loop).\n    formatted += character;\n  }\n\n  formatted = blocks.join('') + formatted;\n\n  return formatted;\n}\n\n/**\n * Get the styles processed for passing through to the element.\n */\nexport function getProcessedStyles(style: string, options: Options): string {\n  const compiled = compile(style);\n  const enhancer = options.isPrefixed\n    ? middleware([prefixer, stringify])\n    : stringify;\n\n  return serialize(compiled, enhancer);\n}\n\n/**\n * Get the styles rendered in the HTML tag.\n */\nexport function getRenderedStyles(style: string, options: Options): string {\n  const processed = getProcessedStyles(style, options);\n\n  return options.isMinified\n    ? processed\n    : /*#__NOINLINE__*/\n      beautify(processed, { autosemicolon: true, indent: '  ' });\n}\n","import { createElement, forwardRef, useMemo, useRef } from 'react';\nimport { createPortal } from 'react-dom';\nimport { createGetCachedLinkHref } from './blob';\nimport { normalizeOptions } from './options';\nimport { getRenderedStyles } from './styles';\n\nimport type { ComponentType, MutableRefObject } from 'react';\nimport type { Options, Props } from '../index.d';\n\ninterface TagProps\n  extends Omit<\n    Props,\n    'children' | 'hasSourceMap' | 'isMinified' | 'isPrefixed'\n  > {}\n\nconst INTERNAL_PROPS: Record<string, true> = {\n  children: true,\n  hasSourceMap: true,\n  isMinified: true,\n  isPrefixed: true,\n};\n\n/**\n * Extract the props used for deriving processed style for passing through to the\n * underlying HTML element.\n */\nfunction useTagProps(props: Props): TagProps {\n  const remainingProps: TagProps = {};\n\n  for (const key in props) {\n    if (!INTERNAL_PROPS[key]) {\n      remainingProps[key] = props[key];\n    }\n  }\n\n  return remainingProps;\n}\n\n/**\n * Calculate and store the style in a local reference.\n */\nfunction useStyle(children: string, options: Options) {\n  const childrenRef = useRef<string>(children);\n  const styleRef = useRef<string>();\n\n  if (!styleRef.current || childrenRef.current !== children) {\n    styleRef.current = getRenderedStyles(children, options);\n    childrenRef.current = children;\n  }\n\n  return styleRef.current;\n}\n\nconst Link = forwardRef<\n  HTMLLinkElement,\n  { passedProps: TagProps; style: string }\n>(function LinkTag({ passedProps, style }, ref) {\n  const getCachedLinkHref = useMemo(createGetCachedLinkHref, []);\n\n  return createElement(\n    'link',\n    Object.assign({}, passedProps, {\n      href: getCachedLinkHref(style),\n      rel: 'stylesheet',\n      ref,\n    })\n  );\n});\n\nexport const Style = forwardRef<HTMLLinkElement | HTMLStyleElement, Props>(\n  function Style(props, ref) {\n    const { hasSourceMap, isMinified, isPrefixed } = props;\n\n    const passedProps = /*#__NOINLINE__*/ useTagProps(props);\n    const options = useMemo(\n      () => normalizeOptions({ hasSourceMap, isMinified, isPrefixed }),\n      [hasSourceMap, isMinified, isPrefixed]\n    );\n    const style = /*#__NOINLINE__*/ useStyle(props.children, options);\n\n    if (options.hasSourceMap) {\n      return createPortal(\n        createElement(Link, {\n          passedProps,\n          ref: ref as MutableRefObject<HTMLLinkElement>,\n          style,\n        }),\n        document.head\n      );\n    }\n\n    return createPortal(\n      createElement('style', Object.assign({}, passedProps, { ref }), style),\n      document.head\n    );\n  }\n) as ComponentType<Props>;\n","let counter = 0;\n\n/**\n * Simple bitwise hash of string value.\n */\nexport function hash<Key extends string>(\n  key: Key\n): `scoped__${Key}__${number}` {\n  const stringToHash = `${key}-${counter++}`;\n\n  let hashValue = 5381;\n  let index = stringToHash.length;\n\n  while (index) {\n    hashValue = (hashValue * 33) ^ stringToHash.charCodeAt(--index);\n  }\n\n  return `scoped__${key}__${hashValue >>> 0}`;\n}\n\n/**\n * Create a hash map based on the keys passed.\n */\nexport function hashKeys<Keys extends readonly string[]>(\n  keys: Keys\n): { [Key in Keys[number]]: `scoped__${Key}__${number}` } {\n  return keys.reduce((hashMap, key: Keys[number]) => {\n    hashMap[key] = hash(key);\n\n    return hashMap;\n  }, {} as { [Key in Keys[number]]: `scoped__${Key}__${number}` });\n}\n"],"names":["noop","createGetCachedLinkHref","href","createObjectURL","getCreateObjectURL","currentStyle","style","Blob","type","undefined","window","URL","webkitURL","IS_PRODUCTION","process","NODE_ENV","env","DEFAULT_OPTIONS","hasSourceMap","isMinified","isPrefixed","globalOptions","Object","assign","hasOwnProperty","prototype","isName","character","indexOf","isQuote","char","isWhitespace","beautify","options","replace","character2","string","quote","_options","_options$autosemicolo","autosemicolon","_options$indent","indent","_options$openbrace","openbrace","openbracesuffix","index","length","blocks","formatted","State","state","depth","comment","appendIndent","openBlock","trimEnd","closeBlock","last","charAt","push","charCodeAt","lastChar","substr","join","getRenderedStyles","processed","compiled","compile","enhancer","middleware","prefixer","stringify","serialize","getProcessedStyles","INTERNAL_PROPS","children","useTagProps","props","remainingProps","key","useStyle","childrenRef","useRef","styleRef","current","Link","forwardRef","_ref","ref","passedProps","getCachedLinkHref","useMemo","createElement","rel","Style","option","normalized","call","normalizeOptions","createPortal","document","head","counter","keys","reduce","hashMap","stringToHash","hashValue","hash"],"mappings":"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"}